<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 更新：版本標示 -->
    <title>AI短文語音生成器 v1.2.0</title>
    <!-- 安全性增強：添加 CSP -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.tailwindcss.com; style-src 'self' 'unsafe-inline' https://cdn.tailwindcss.com; img-src 'self' data:; connect-src 'self' blob:; media-src 'self' blob:;">
    <!-- 載入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 額外樣式，確保 Inter 字體被使用 */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* 按鈕載入中樣式 */
        .btn-loading {
            position: relative;
            pointer-events: none;
            color: transparent !important;
        }
        .btn-loading::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            margin-left: -0.75rem; /* 1.5rem / 2 */
            margin-top: -0.75rem; /* 1.5rem / 2 */
            width: 1.5rem;
            height: 1.5rem;
            border: 2px solid #fff;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<!-- 靠上對齊 (v1.1.1: 修改 body 為 flex-col, items-center 以便放置卡片外的按鈕) -->
<body class="bg-gray-100 flex flex-col items-center min-h-screen p-4 sm:p-8 pt-16 sm:pt-24">

    <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-xl">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">AI短文語音生成器</h1>
        
        <!-- 1. 輸入區域 -->
        <div class="mb-6">
            <label for="word-input" class="block text-sm font-medium text-gray-700 mb-2">請輸入英文字（用逗號或空白分隔）:</label>
            <textarea id="word-input" rows="3" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent" placeholder="例如: study, subject, honest, science, library, history, homework, important"></textarea>
            
            <div class="mt-4 flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-3">
                <button id="generate-button" class="w-full sm:w-3/4 bg-blue-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 transition-all duration-300 ease-in-out">
                    生成短文
                </button>
                <button id="clear-button" class="w-full sm:w-1/4 bg-gray-500 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-50 transition-all duration-300 ease-in-out">
                    清除
                </button>
            </div>
            <p id="passage-status" class="text-center text-sm text-gray-500 mt-3 h-5"></p>
        </div>

        <!-- 2. 輸出區域 (預設隱藏) -->
        <div id="output-section" class="hidden border-t pt-6">
            <h2 class="text-xl font-semibold text-gray-800 mb-4">生成的短文:</h2>
            
            <p id="passage-display" class="text-lg text-gray-700 bg-gray-50 p-4 rounded-lg leading-relaxed mb-6 min-h-[50px]">
                <!-- 短文將顯示在這裡 -->
            </p>

            <button id="play-button" class="w-full bg-green-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50 transition-all duration-300 ease-in-out">
                播放語音 (英文)
            </button>
            <audio id="audio-player" class="w-full mt-4" controls></audio>
            <p id="audio-status" class="text-center text-sm text-gray-500 mt-3 h-5"></p>


            <button id="translate-button" class="mt-6 w-full bg-indigo-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50 transition-all duration-300 ease-in-out">
                翻譯成中文
            </button>
            <p id="translation-status" class="text-center text-sm text-gray-500 mt-3 h-5"></p>

            <div id="translation-section" class="hidden mt-4">
                <h3 class="text-lg font-semibold text-gray-800 mb-2">中文翻譯:</h3>
                <p id="translation-display" class="text-lg text-gray-700 bg-indigo-50 p-4 rounded-lg leading-relaxed">
                    <!-- 翻譯將顯示在這裡 -->
                </p>
            </div>
            
        </div>

        <!-- 更新：版本標示 -->
        <div class="text-center text-xs text-gray-400 mt-6 pt-4 border-t border-gray-100">
            版本 v1.2.0 - 增強安全性和性能
        </div>
    </div>

    <!-- v1.1.1 新增：重新開始按鈕 (卡片外部) -->
    <button id="restart-button-bottom" class="w-full max-w-xl mt-6 bg-gray-500 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-50 transition-all duration-300 ease-in-out">
        重新開始
    </button>
    <!-- v1.1.1 新增：底部間距 -->
    <div class="h-16"></div> 


    <script type="module">
        // --- v1.2.0: 增強版本 - 改進安全性、性能和錯誤處理 ---

        // --- DOM 元素 ---
        const wordInput = document.getElementById('word-input');
        const generateButton = document.getElementById('generate-button');
        const clearButton = document.getElementById('clear-button');
        const passageStatus = document.getElementById('passage-status');

        const outputSection = document.getElementById('output-section');
        const passageDisplay = document.getElementById('passage-display');

        const translateButton = document.getElementById('translate-button');
        const translationSection = document.getElementById('translation-section');
        const translationDisplay = document.getElementById('translation-display');
        const translationStatus = document.getElementById('translation-status');

        const playButton = document.getElementById('play-button');
        const audioPlayer = document.getElementById('audio-player');
        const audioStatus = document.getElementById('audio-status');
        const restartButtonBottom = document.getElementById('restart-button-bottom');

        // --- API 設定 ---
        const textGenApiUrl = `/.netlify/functions/generate-text`;
        const ttsApiUrl = `/.netlify/functions/generate-audio`;

        // --- 配置常量 ---
        const MAX_INPUT_LENGTH = 500; // 最大輸入字符數
        const MAX_WORDS = 50; // 最大單詞數
        const REQUEST_TIMEOUT = 60000; // 請求超時 (60 秒)

        // --- 狀態管理 ---
        let currentAudioUrl = null; // 追蹤當前音頻 URL 以便清理
        let wordHighlightRegexCache = null; // 緩存正則表達式


        // --- 事件監聽 ---
        generateButton.addEventListener('click', handleGeneratePassage);
        clearButton.addEventListener('click', handleClear); 
        playButton.addEventListener('click', handlePlayAudio);
        translateButton.addEventListener('click', handleTranslatePassage); 
        // v1.1.1 新增
        restartButtonBottom.addEventListener('click', handleClear);

        /**
         * 清理舊的音頻 URL 以防止內存洩漏
         */
        function cleanupAudioUrl() {
            if (currentAudioUrl) {
                URL.revokeObjectURL(currentAudioUrl);
                currentAudioUrl = null;
            }
        }

        /**
         * 安全的文本轉義（防止 XSS）
         */
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * 驗證輸入
         */
        function validateInput(words) {
            // 檢查長度
            if (words.length > MAX_INPUT_LENGTH) {
                return {
                    valid: false,
                    error: `輸入過長！最多 ${MAX_INPUT_LENGTH} 個字符（當前: ${words.length}）。`
                };
            }

            const inputWords = words.split(/[\s,、]+/).filter(Boolean);

            if (inputWords.length === 0) {
                return {
                    valid: false,
                    error: "請輸入有效的單字。"
                };
            }

            if (inputWords.length > MAX_WORDS) {
                return {
                    valid: false,
                    error: `單詞數量過多！最多 ${MAX_WORDS} 個（當前: ${inputWords.length}）。`
                };
            }

            return { valid: true, words: inputWords };
        }

        /**
         * 處理：生成短文
         */
        async function handleGeneratePassage() {
            const words = wordInput.value.trim();
            if (!words) {
                setStatus(passageStatus, "請至少輸入一個單字。", "error");
                return;
            }

            // 驗證輸入
            const validation = validateInput(words);
            if (!validation.valid) {
                setStatus(passageStatus, validation.error, "error");
                return;
            }

            const inputWords = validation.words;

            setLoading(generateButton, true);
            setStatus(passageStatus, "短文生成中，請稍候...", "info");
            outputSection.classList.add('hidden');
            passageDisplay.textContent = "";
            cleanupAudioUrl(); // 清理舊音頻
            audioPlayer.src = "";

            translationSection.classList.add('hidden');
            translationDisplay.textContent = "";
            setStatus(translationStatus, "", "info");
            wordHighlightRegexCache = null; // 清除緩存

            const prompt = `You MUST write a short, coherent paragraph (about 2-3 sentences) that uses ALL of the following English words: ${inputWords.join(', ')}. Every single word from the list must be included. Do not add any preamble. Only return the paragraph text.`;

            try {
                const payload = {
                    prompt: prompt,
                    systemInstruction: "You are a helpful assistant. You must generate a single paragraph that uses all the user's provided words. Output only the paragraph text, with no preamble or any other text."
                };

                const response = await fetchWithTimeout(textGenApiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                }, REQUEST_TIMEOUT);

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error?.message || `API 請求失敗: ${response.status}`);
                }

                let result;
                try {
                    result = await response.json();
                } catch (jsonError) {
                    throw new Error("無法解析伺服器響應。");
                }

                const passage = result.candidates?.[0]?.content?.parts?.[0]?.text;

                if (passage) {
                    // 安全地高亮單詞（防止 XSS）
                    const escapedWords = inputWords.map(word =>
                        word.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')
                    );
                    wordHighlightRegexCache = new RegExp(`\\b(${escapedWords.join('|')})\\b`, 'gi');

                    // 先轉義整個文本，然後高亮匹配的單詞
                    const escapedPassage = escapeHtml(passage);
                    const highlightedPassage = escapedPassage.replace(
                        wordHighlightRegexCache,
                        '<mark class="bg-yellow-200 rounded px-1">$1</mark>'
                    );

                    passageDisplay.innerHTML = highlightedPassage;
                    outputSection.classList.remove('hidden');
                    setStatus(passageStatus, "短文生成成功！", "success");
                    setStatus(audioStatus, "", "info");
                } else {
                    if (result.error) {
                        throw new Error(`API 錯誤: ${result.error.message}`);
                    }
                    throw new Error("API 未返回有效內容。");
                }

            } catch (error) {
                console.error("短文生成失敗:", error);
                setStatus(passageStatus, `錯誤: ${error.message}`, "error");
            } finally {
                setLoading(generateButton, false);
            }
        }

        /**
         * 處理翻譯
         */
        async function handleTranslatePassage() {
            const textToTranslate = passageDisplay.textContent;
            if (!textToTranslate) {
                setStatus(translationStatus, "沒有可翻譯的文字。", "error");
                return;
            }

            setLoading(translateButton, true);
            setStatus(translationStatus, "翻譯中...", "info");
            translationSection.classList.add('hidden');

            const prompt = `Translate the following English text to Traditional Chinese: "${textToTranslate}". Only return the Traditional Chinese text, nothing else.`;

            try {
                const payload = {
                    prompt: prompt,
                    systemInstruction: "You are a helpful assistant. You only output the Traditional Chinese translation, with no preamble or any other text."
                };

                const response = await fetchWithTimeout(textGenApiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                }, REQUEST_TIMEOUT);

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error?.message || `API 請求失敗: ${response.status}`);
                }

                let result;
                try {
                    result = await response.json();
                } catch (jsonError) {
                    throw new Error("無法解析伺服器響應。");
                }

                const translatedText = result.candidates?.[0]?.content?.parts?.[0]?.text;

                if (translatedText) {
                    translationDisplay.textContent = translatedText;
                    translationSection.classList.remove('hidden');
                    setStatus(translationStatus, "翻譯成功！", "success");
                } else {
                    if (result.error) {
                        throw new Error(`API 錯誤: ${result.error.message}`);
                    }
                    throw new Error("API 未返回有效的翻譯內容。");
                }

            } catch (error) {
                console.error("翻譯失敗:", error);
                setStatus(translationStatus, `錯誤: ${error.message}`, "error");
            } finally {
                setLoading(translateButton, false);
            }
        }


        /**
         * 處理：播放語音 (英文原文)
         */
        async function handlePlayAudio() {
            const textToSpeak = passageDisplay.textContent;
            if (!textToSpeak) {
                setStatus(audioStatus, "沒有可播放的文字。", "error");
                return;
            }

            setLoading(playButton, true);
            setStatus(audioStatus, "語音生成中...", "info");

            try {
                const payload = {
                    text: `Say clearly: ${textToSpeak}`
                };

                const response = await fetchWithTimeout(ttsApiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                }, REQUEST_TIMEOUT);

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error?.message || `API 請求失敗: ${response.status}`);
                }

                let result;
                try {
                    result = await response.json();
                } catch (jsonError) {
                    throw new Error("無法解析伺服器響應。");
                }

                const part = result?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
                    const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                    if (!sampleRateMatch) {
                        throw new Error("無法從 mimeType 獲取 sampleRate");
                    }
                    const sampleRate = parseInt(sampleRateMatch[1], 10);

                    // 使用 try-catch 保護音頻轉換
                    try {
                        const pcmData = base64ToArrayBuffer(audioData);
                        const pcm16 = new Int16Array(pcmData);
                        const wavBlob = pcmToWav(pcm16, sampleRate);

                        // 清理舊的音頻 URL
                        cleanupAudioUrl();

                        // 創建新的音頻 URL
                        currentAudioUrl = URL.createObjectURL(wavBlob);
                        audioPlayer.src = currentAudioUrl;
                        await audioPlayer.play();

                        setStatus(audioStatus, "播放中...", "success");
                    } catch (audioError) {
                        throw new Error(`音頻處理失敗: ${audioError.message}`);
                    }

                } else {
                    if (result.error) {
                        throw new Error(`API 錯誤: ${result.error.message}`);
                    }
                    throw new Error("從 API 回應中找不到有效的音訊數據。");
                }

            } catch (error) {
                console.error("語音生成失敗:", error);
                setStatus(audioStatus, `錯誤: ${error.message}`, "error");
            } finally {
                setLoading(playButton, false);
            }
        }

        /**
         * 處理清除功能
         */
        function handleClear() {
            wordInput.value = "";
            outputSection.classList.add('hidden');
            passageDisplay.textContent = "";
            cleanupAudioUrl(); // 清理音頻 URL
            audioPlayer.src = "";
            audioPlayer.pause();
            setStatus(passageStatus, "", "info");
            setStatus(audioStatus, "", "info");

            translationSection.classList.add('hidden');
            translationDisplay.textContent = "";
            setStatus(translationStatus, "", "info");

            wordHighlightRegexCache = null; // 清除緩存

            setLoading(generateButton, false);
            setLoading(playButton, false);
            setLoading(translateButton, false);
        }

        // --- 輔助函式 (保持不變) ---

        function setLoading(button, isLoading) {
            if (isLoading) {
                button.classList.add('btn-loading');
                button.disabled = true;
            } else {
                button.classList.remove('btn-loading');
                button.disabled = false;
            }
        }

        function setStatus(element, message, type = "info") {
            element.textContent = message;
            if (type === "error") {
                element.className = "text-center text-sm text-red-500 mt-3 h-5";
            } else if (type === "success") {
                element.className = "text-center text-sm text-green-500 mt-3 h-5";
            } else {
                element.className = "text-center text-sm text-gray-500 mt-3 h-5";
            }
        }
        
        /**
         * 帶超時和重試的 fetch（支持退避策略）
         */
        async function fetchWithTimeout(url, options, timeout = REQUEST_TIMEOUT, maxRetries = 3) {
            let delay = 1000;

            for (let i = 0; i < maxRetries; i++) {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), timeout);

                try {
                    const response = await fetch(url, {
                        ...options,
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    // 對於速率限制和伺服器錯誤，進行重試
                    if (response.status === 429 || (response.status >= 500 && response.status <= 599)) {
                        if (i < maxRetries - 1) {
                            await new Promise(resolve => setTimeout(resolve, delay));
                            delay *= 2;
                            continue;
                        }
                    }

                    return response;

                } catch (error) {
                    clearTimeout(timeoutId);

                    if (error.name === 'AbortError') {
                        throw new Error(`請求超時（${timeout / 1000} 秒）。請稍後重試。`);
                    }

                    if (i === maxRetries - 1) {
                        throw error;
                    }

                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2;
                }
            }
        }

        /**
         * 優化的 Base64 解碼（更高效）
         */
        function base64ToArrayBuffer(base64) {
            try {
                const binaryString = atob(base64);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            } catch (error) {
                throw new Error(`Base64 解碼失敗: ${error.message}`);
            }
        }

        function pcmToWav(pcmData, sampleRate) {
            const numChannels = 1;
            const bitsPerSample = 16;
            const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
            const blockAlign = numChannels * (bitsPerSample / 8);
            const dataSize = pcmData.length * (bitsPerSample / 8);
            const fileSize = 36 + dataSize;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);

            writeString(view, 0, 'RIFF');
            view.setUint32(4, fileSize, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);

            let offset = 44;
            for (let i = 0; i < pcmData.length; i++, offset += 2) {
                view.setInt16(offset, pcmData[i], true);
            }

            return new Blob([view], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

    </script>
</body>
</html>

