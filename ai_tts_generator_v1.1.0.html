<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- v1.1.4 更新：版本標示 -->
    <title>AI短文語音生成器 v1.1.4</title>
    <!-- 載入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 額外樣式，確保 Inter 字體被使用 */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* 按鈕載入中樣式 */
        .btn-loading {
            position: relative;
            pointer-events: none;
            color: transparent !important;
        }
        .btn-loading::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            margin-left: -0.75rem; /* 1.5rem / 2 */
            margin-top: -0.75rem; /* 1.5rem / 2 */
            width: 1.5rem;
            height: 1.5rem;
            border: 2px solid #fff;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* v1.1.3 新增：歷史紀錄樣式 */
        .history-item {
            border: 1px solid #e5e7eb; /* gray-200 */
            padding: 0.75rem;
            border-radius: 0.5rem; /* rounded-lg */
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .history-item:hover {
            background-color: #f9fafb; /* gray-50 */
        }
        .history-item-words {
            font-weight: 600; /* font-semibold */
            color: #4b5563; /* gray-600 */
            margin-bottom: 0.25rem;
        }
        .history-item-passage {
            font-size: 0.875rem; /* text-sm */
            color: #6b7280; /* gray-500 */
            /* 限制行數 */
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center min-h-screen p-4 sm:p-8 pt-16 sm:pt-24">

    <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-xl">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">AI短文語音生成器</h1>
        
        <!-- 1. 輸入區域 -->
        <div class="mb-6">
            <label for="word-input" class="block text-sm font-medium text-gray-700 mb-2">請輸入英文字 (用頓號、逗號或空白分隔):</label>
            <textarea id="word-input" rows="3" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent" placeholder="例如: history、homework、important"></textarea>
            
            <div class="mt-4 flex flex-col sm:flex-row gap-3">
                <button id="generate-button" class="w-full sm:w-2/3 bg-blue-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 transition-all duration-300 ease-in-out">
                    生成短文
                </button>
                <button id="clear-button" class="w-full sm:w-1/3 bg-gray-400 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-50 transition-all duration-300 ease-in-out">
                    清除
                </button>
            </div>
            <p id="passage-status" class="text-center text-sm text-gray-500 mt-3 h-5"></p>
        </div>

        <!-- v1.1.3: 歷史紀錄區域 -->
        <div id="history-section" class="mb-6 border-t pt-6">
             <h2 class="text-xl font-semibold text-gray-800 mb-4">歷史紀錄 (最近 3 筆)</h2>
             <div id="history-list">
                <!-- 歷史紀錄將動態插入這裡 -->
             </div>
        </div>

        <!-- 2. 輸出區域 (預設隱藏) -->
        <div id="output-section" class="hidden border-t pt-6">
            <h2 class="text-xl font-semibold text-gray-800 mb-4">生成的短文:</h2>
            <p id="passage-display" class="text-lg text-gray-700 bg-gray-50 p-4 rounded-lg leading-relaxed mb-6 min-h-[50px]">
                <!-- 短文將顯示在這裡 -->
            </p>

            <!-- v1.1.4: 移除 grid 和 play-sync-button，恢復單一按鈕 -->
            <button id="play-button" class="w-full bg-green-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50 transition-all duration-300 ease-in-out">
                播放語音
            </button>
            <audio id="audio-player" class="w-full mt-4" controls></audio>
            <p id="audio-status" class="text-center text-sm text-gray-500 mt-3 h-5"></p>

            <button id="translate-button" class="mt-6 w-full bg-indigo-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50 transition-all duration-300 ease-in-out">
                翻譯成中文
            </button>
            
            <div id="translation-output" class="hidden mt-6">
                <h2 class="text-xl font-semibold text-gray-800 mb-4">中文翻譯:</h2>
                <p id="translation-display" class="text-lg text-gray-700 bg-gray-50 p-4 rounded-lg leading-relaxed min-h-[50px]"></p>
                <p id="translation-status" class="text-center text-sm text-gray-500 mt-3 h-5"></p>
            </div>
        </div>

        <!-- v1.1.4 更新：版本標示 -->
        <div class="text-center text-xs text-gray-400 mt-6 pt-4 border-t border-gray-100">
            版本 v1.1.4
        </div>
    </div>
    
    <button id="restart-button-bottom" class="w-full max-w-xl mt-6 bg-gray-500 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-50 transition-all duration-300 ease-in-out">
        重新開始
    </button>
    <div class="h-16"></div> 


    <script type="module">
        // --- DOM 元素 ---
        const wordInput = document.getElementById('word-input');
        const generateButton = document.getElementById('generate-button');
        const clearButton = document.getElementById('clear-button');
        const passageStatus = document.getElementById('passage-status');
        
        const outputSection = document.getElementById('output-section');
        const passageDisplay = document.getElementById('passage-display');
        
        const playButton = document.getElementById('play-button');
        // v1.1.4: 移除 playSyncButton
        const audioPlayer = document.getElementById('audio-player');
        const audioStatus = document.getElementById('audio-status');

        const translateButton = document.getElementById('translate-button');
        const translationOutput = document.getElementById('translation-output');
        const translationDisplay = document.getElementById('translation-display');
        const translationStatus = document.getElementById('translation-status');
        
        const restartButtonBottom = document.getElementById('restart-button-bottom');
        
        const historySection = document.getElementById('history-section');
        const historyList = document.getElementById('history-list');

        // v1.1.4: 移除 Web Speech API 相關變數
        
        // --- API 設定 ---
        const textGenApiUrl = `/.netlify/functions/generate-text`;
        const ttsApiUrl = `/.netlify/functions/generate-audio`;
        
        // --- v1.1.3: 儲存相關 ---
        const HISTORY_KEY = 'passageHistory';
        let history = [];


        // --- 事件監聽 ---
        document.addEventListener('DOMContentLoaded', loadHistory); 
        generateButton.addEventListener('click', handleGeneratePassage);
        clearButton.addEventListener('click', handleClear); 
        playButton.addEventListener('click', handlePlayAudio);
        translateButton.addEventListener('click', handleTranslatePassage); 
        restartButtonBottom.addEventListener('click', handleClear);
        // v1.1.4: 移除 playSyncButton 監聽
        historyList.addEventListener('click', handleHistoryClick); 


        /**
         * v1.0.2: 處理：清除所有內容
         */
        function handleClear() {
            wordInput.value = "";
            outputSection.classList.add('hidden');
            passageDisplay.innerHTML = "";
            passageStatus.textContent = "";
            audioStatus.textContent = "";
            audioPlayer.src = "";
            translationOutput.classList.add('hidden'); 
            translationDisplay.textContent = ""; 
            translationStatus.textContent = ""; 
            
            // v1.1.4: 移除 Web Speech 相關邏輯
        }

        /**
         * 處理：生成短文
         */
        async function handleGeneratePassage() {
            const words = wordInput.value.trim().split(/[\s、,]+/).filter(Boolean);
            if (words.length === 0) {
                setStatus(passageStatus, "請至少輸入一個單字。", "error");
                return;
            }

            setLoading(generateButton, true);
            setStatus(passageStatus, "短文生成中，請稍候...", "info");
            handleClear(); 
            outputSection.classList.add('hidden');

            const prompt = `You MUST write a short, simple, coherent English paragraph (about 2-3 sentences) that correctly uses ALL of the following words: ${words.join(', ')}.`;

            try {
                const payload = {
                    prompt: prompt,
                    systemInstruction: "You are a helpful assistant. You MUST use all the provided words. You only output the single generated paragraph text, with no preamble or any other text."
                };

                const response = await fetchWithBackoff(textGenApiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `API 請求失敗: ${response.status}`);
                }

                const result = await response.json();
                const passage = result.text;

                if (passage) {
                    let highlightedPassage = escapeHTML(passage); 
                    words.forEach(word => {
                        const regex = new RegExp(`(${escapeRegExp(word)})`, 'gi');
                        highlightedPassage = highlightedPassage.replace(regex, `<mark class="bg-yellow-200 p-0.5 rounded">$1</mark>`);
                    });
                    
                    passageDisplay.innerHTML = highlightedPassage; 
                    // v1.1.4: 移除 originalPassageHTML 
                    
                    outputSection.classList.remove('hidden'); 
                    setStatus(passageStatus, "短文生成成功！", "success");
                    
                    saveHistory(words.join(', '), highlightedPassage);

                    // v1.1.4: 移除 synth 檢查
                } else {
                    throw new Error("API 未返回有效內容。");
                }

            } catch (error) {
                console.error("短文生成失敗:", error);
                setStatus(passageStatus, `錯誤: ${error.message}`, "error");
            } finally {
                setLoading(generateButton, false);
            }
        }

        /**
         * v1.0.8: 處理：翻譯短文
         */
        async function handleTranslatePassage() {
            const textToTranslate = passageDisplay.textContent;
            if (!textToTranslate) {
                setStatus(translationStatus, "沒有可翻譯的文字。", "error");
                return;
            }

            setLoading(translateButton, true);
            setStatus(translationStatus, "翻譯中...", "info");
            translationOutput.classList.remove('hidden');
            translationDisplay.textContent = "";

            const prompt = `Translate the following English text to Traditional Chinese: ${textToTranslate}`;

            try {
                const payload = {
                    prompt: prompt,
                    systemInstruction: "You are a translation assistant. You only output the Traditional Chinese translation, nothing else."
                };

                const response = await fetchWithBackoff(textGenApiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `API 請求失敗: ${response.status}`);
                }
                
                const result = await response.json();
                const translation = result.text;

                if (translation) {
                    translationDisplay.textContent = translation;
                    setStatus(translationStatus, "翻譯成功！", "success");
                } else {
                    throw new Error("API 未返回有效的翻譯內容。");
                }

            } catch (error) {
                console.error("翻譯失敗:", error);
                setStatus(translationStatus, `錯誤: ${error.message}`, "error");
            } finally {
                setLoading(translateButton, false);
            }
        }


        /**
         * 處理：播放 AI 語音
         */
        async function handlePlayAudio() {
            // v1.1.4: 移除 synth 相關邏輯
            
            const textToSpeak = passageDisplay.textContent; 
            if (!textToSpeak) {
                setStatus(audioStatus, "沒有可播放的文字。", "error");
                return;
            }

            setLoading(playButton, true);
            // v1.1.4: 移除 setLoading(playSyncButton, false); 
            setStatus(audioStatus, "AI 語音生成中...", "info");

            try {
                const payload = {
                    text: `Say clearly: ${textToSpeak}`
                };
                
                const response = await fetchWithBackoff(ttsApiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `API 請求失敗: ${response.status}`);
                }

                const result = await response.json();
                const audioData = result.audioData;
                const mimeType = result.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
                    const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                    if (!sampleRateMatch) {
                        throw new Error("無法從 mimeType 獲取 sampleRate");
                    }
                    const sampleRate = parseInt(sampleRateMatch[1], 10);

                    const pcmData = base64ToArrayBuffer(audioData);
                    const pcm16 = new Int16Array(pcmData);
                    const wavBlob = pcmToWav(pcm16, sampleRate);
                    const audioUrl = URL.createObjectURL(wavBlob);
                    
                    audioPlayer.src = audioUrl;
                    audioPlayer.play();
                    
                    setStatus(audioStatus, "AI 語音播放中...", "success");

                } else {
                    throw new Error("從 API 回應中找不到有效的音訊數據。");
                }

            } catch (error) {
                console.error("語音生成失敗:", error);
                setStatus(audioStatus, `錯誤: ${error.message}`, "error");
            } finally {
                setLoading(playButton, false);
            }
        }
        
        // v1.1.4: 移除 handlePlaySyncAudio 整個函式

        // --- v1.1.3: 歷史紀錄輔助函式 ---

        function loadHistory() {
            try {
                const storedHistory = localStorage.getItem(HISTORY_KEY);
                if (storedHistory) {
                    history = JSON.parse(storedHistory);
                }
            } catch (e) {
                console.error("讀取歷史紀錄失敗:", e);
                history = [];
            }
            renderHistory();
        }

        function saveHistory(words, passageHTML) {
            const newEntry = {
                id: new Date().getTime(),
                words: words,
                passage: passageHTML
            };
            
            history.unshift(newEntry);
            history = history.slice(0, 3);
            
            try {
                localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
            } catch (e) {
                console.error("儲存歷史紀錄失敗:", e);
            }
            
            renderHistory();
        }

        function renderHistory() {
            historyList.innerHTML = ""; 
            if (history.length === 0) {
                historyList.innerHTML = `<p class="text-sm text-gray-500">目前沒有歷史紀錄。</p>`;
                historySection.classList.add('hidden'); 
            } else {
                historySection.classList.remove('hidden'); 
                history.forEach(entry => {
                    const item = document.createElement('div');
                    item.className = 'history-item';
                    item.dataset.id = entry.id;
                    
                    const itemWords = document.createElement('div');
                    itemWords.className = 'history-item-words';
                    itemWords.textContent = `單字: ${entry.words}`;
                    
                    const itemPassage = document.createElement('div');
                    itemPassage.className = 'history-item-passage';
                    itemPassage.innerHTML = `短文: ${entry.passage}`; 
                    
                    item.appendChild(itemWords);
                    item.appendChild(itemPassage);
                    historyList.appendChild(item);
                });
            }
        }

        function handleHistoryClick(e) {
            const item = e.target.closest('.history-item');
            if (!item) return;
            
            const id = Number(item.dataset.id);
            const entry = history.find(h => h.id === id);
            
            if (entry) {
                handleClear(); 
                wordInput.value = entry.words;
                passageDisplay.innerHTML = entry.passage;
                // v1.1.4: 移除 originalPassageHTML
                outputSection.classList.remove('hidden');
                setStatus(passageStatus, "已從歷史紀錄載入。", "success");
            }
        }


        // --- 輔助函式 ---

        function setLoading(button, isLoading) {
            if (isLoading) {
                button.classList.add('btn-loading');
                button.disabled = true;
            } else {
                button.classList.remove('btn-loading');
                button.disabled = false;
            }
        }

        function setStatus(element, message, type = "info") {
            element.textContent = message;
            const classMap = {
                "error": "text-center text-sm text-red-500 mt-3 h-5",
                "success": "text-center text-sm text-green-500 mt-3 h-5",
                "info": "text-center text-sm text-gray-500 mt-3 h-5"
            };
            element.className = classMap[type] || classMap["info"];
        }
        
        async function fetchWithBackoff(url, options, maxRetries = 3) {
            let delay = 1000; 
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.status === 429 || (response.status >= 500 && response.status <= 599)) {
                        throw new Error(`Server error ${response.status}`);
                    }
                    return response;
                } catch (error) {
                    if (i === maxRetries - 1) throw error; 
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2; 
                }
            }
        }

        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function pcmToWav(pcmData, sampleRate) {
            const numChannels = 1;
            const bitsPerSample = 16;
            const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
            const blockAlign = numChannels * (bitsPerSample / 8);
            const dataSize = pcmData.length * (bitsPerSample / 8);
            const fileSize = 36 + dataSize;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);

            writeString(view, 0, 'RIFF');
            view.setUint32(4, fileSize, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);

            let offset = 44;
            for (let i = 0; i < pcmData.length; i++, offset += 2) {
                view.setInt16(offset, pcmData[i], true);
            }

            return new Blob([view], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }
        
        function escapeHTML(str) {
            return str.replace(/[&<>"']/g, function(match) {
                return {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#39;'
                }[match];
            });
        }
        
        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); 
        }

    </script>
</body>
</html>

